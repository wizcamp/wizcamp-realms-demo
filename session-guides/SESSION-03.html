<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>SESSION-03 - Wizcamp Session Guide</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">

@page {
margin: 0.6in 0.75in 0.6in 0.75in;
size: letter;
}
body {
font-family: "Roboto", -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
font-size: 16px;
line-height: 1.4;
color: #1f2328;
margin: 0;
padding: 0;
max-width: none;
}
h1, h2, h3, h4, h5, h6 {
font-family: "Roboto", -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
font-weight: 600;
line-height: 1.25;
margin-bottom: 16px;
margin-top: 24px;
}
h1 {
font-size: 1.75em;
border-bottom: 1px solid #d0d7de;
padding-bottom: 0.3em;
margin-top: 0;
}
h2 {
font-size: 1.5em;
border-bottom: 1px solid #d0d7de;
padding-bottom: 0.3em;
margin-top: 36px;
margin-bottom: 18px;
page-break-after: avoid;
}

h1 + * h2:first-of-type,
h2:first-of-type {
margin-top: 24px;
}

a[id] {
scroll-margin-top: 20px;
}
h3 {
font-size: 1.25em;
margin-top: 24px;
margin-bottom: 12px;
page-break-after: avoid;
break-after: avoid;
}

h3 + ol,
h3 + ul,
h3 + p {
page-break-before: avoid;
break-before: avoid;
}

ol, ul {
page-break-inside: avoid;
break-inside: avoid;
}

h3 {
orphans: 2;
widows: 2;
}
code {
font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, "SF Mono", Consolas, monospace !important;
font-size: 13px !important;
font-weight: 500 !important;
background-color: #f1f3f4 !important;
color: #c7254e !important;
padding: 2px 4px !important;
border-radius: 3px !important;
border: 1px solid #d1d5da !important;
white-space: nowrap;
word-break: break-word;
-webkit-print-color-adjust: exact !important;
print-color-adjust: exact !important;
}
pre {
font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, "SF Mono", Consolas, monospace !important;
background-color: #f8f9fa !important;
border: 1px solid #e1e4e8 !important;
border-radius: 6px !important;
padding: 16px !important;
overflow: visible !important;
white-space: pre !important;
word-wrap: normal !important;
page-break-inside: avoid !important;
-webkit-print-color-adjust: exact !important;
print-color-adjust: exact !important;
font-size: 14px !important;
line-height: 1.4 !important;
display: block !important;
width: 100% !important;
}

@media print {
pre {
white-space: pre !important;
font-family: "JetBrains Mono", monospace !important;
display: block !important;
}
pre * {
white-space: pre !important;
}
}
pre code {
background-color: transparent !important;
border: none !important;
padding: 0 !important;
color: #24292f !important;
}
ul, ol {
padding-left: 1.8em;
margin-bottom: 12px;
}
li {
margin-bottom: 6px;
line-height: 1.4;
}

@media print {
ul, ol {
page-break-inside: avoid;
display: block !important;
}
li {
page-break-inside: avoid;
display: list-item !important;
margin-bottom: 8px !important;
}

* {
box-sizing: border-box !important;
}
}
p {
margin-bottom: 12px;
}
a {
color: #0969da;
text-decoration: none;
}
strong {
font-weight: 600;
}

table {
border-collapse: collapse;
border-spacing: 0;
width: 100%;
margin: 16px 0;
font-size: 16px;
line-height: 1.5;
}
th, td {
padding: 12px 16px;
text-align: left;
vertical-align: top;
border: 1px solid #d0d7de;
}
th {
font-weight: 600;
background-color: #f6f8fa;
color: #24292f;
-webkit-print-color-adjust: exact !important;
print-color-adjust: exact !important;
}
tbody tr:nth-child(even) {
background-color: #f8f9fa;
-webkit-print-color-adjust: exact !important;
print-color-adjust: exact !important;
}

table code {
font-size: 14px !important;
padding: 2px 4px !important;
}

table td:first-child {
min-width: 150px;
}

table {
page-break-inside: auto !important;
}
th {
page-break-after: avoid !important;
}
tbody tr {
page-break-inside: avoid !important;
page-break-after: auto !important;
}

thead {
display: table-header-group !important;
}
@media print {
thead {
display: table-row-group !important;
}
table {
page-break-inside: auto !important;
}
tr {
page-break-inside: avoid !important;
}
}
</style>
</head>
<body>
<h1 id="session-3-managing-game-flow">Session 3 â€” Managing Game Flow</h1>
<p>Shared State with Context ğŸ®</p>
<p>Youâ€™re about to unlock one of Reactâ€™s most powerful features â€” shared state that controls your entire app! This guide walks you through implementing screen navigation, understanding the difference between local and shared state, and using Reactâ€™s Context API to manage game flow. Ready to make your buttons actually navigate? Letâ€™s go!</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#access-your-codespace">Access Your Codespace</a></li>
<li><a href="#understanding-state-vs-props">Understanding State vs Props</a></li>
<li><a href="#exploring-game-constants">Exploring Game Constants</a></li>
<li><a href="#adding-screen-navigation">Adding Screen Navigation</a></li>
<li><a href="#using-react-devtools-to-explore-state">Using React DevTools to Explore State</a></li>
<li><a href="#implementing-start-game-functionality">Implementing Start Game Functionality</a></li>
<li><a href="#adding-local-state-for-credits">Adding Local State for Credits</a></li>
<li><a href="#essential-terms">Essential Terms</a></li>
<li><a href="#ask-the-ai">Ask the AI</a></li>
</ul>
<p><a id="access-your-codespace"></a></p>
<h2 id="access-your-codespace">â˜ï¸ Access Your Codespace</h2>
<p>Visit <a href="https://github.com/codespaces">github.com/codespaces</a> to relaunch your Codespace from Session 2.</p>
<p><a id="understanding-state-vs-props"></a></p>
<h2 id="understanding-state-vs-props">ğŸ§  Understanding State vs Props</h2>
<p>Before we dive into code, letâ€™s understand the key difference between <strong>state</strong> and <strong>props</strong> â€” two fundamental concepts that control how data flows in React apps.</p>
<h3 id="props-vs-state-the-key-differences">Props vs State: The Key Differences</h3>
<table>
<thead>
<tr class="header">
<th><strong>Props</strong></th>
<th><strong>State</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Data flows <strong>down</strong> from parent to child</td>
<td>Data lives <strong>inside</strong> a component</td>
</tr>
<tr class="even">
<td><strong>Read-only</strong> â€” child canâ€™t change them</td>
<td><strong>Changeable</strong> â€” component can update it</td>
</tr>
<tr class="odd">
<td>Like function parameters</td>
<td>Like component memory</td>
</tr>
<tr class="even">
<td>External data</td>
<td>Internal data</td>
</tr>
</tbody>
</table>
<h3 id="why-this-matters">ğŸ’¡ Why This Matters</h3>
<p><strong>Props</strong> are like ingredients you receive to make a recipe â€” you canâ€™t change them, but you use them to create something. <strong>State</strong> is like your kitchenâ€™s current condition â€” you can rearrange, add, or remove things as needed. Understanding this difference is crucial because it determines how data flows through your app and which component is responsible for managing what information.</p>
<p><a id="exploring-game-constants"></a></p>
<h2 id="exploring-game-constants">ğŸ“‹ Exploring Game Constants</h2>
<p>Letâ€™s start by understanding how our game screens are organized using <strong>constants</strong> â€” static values that prevent typos and make code more maintainable.</p>
<ol type="1">
<li><strong>Explore the screens constant</strong>: Open <code>src/constants/screens.js</code> and examine the SCREENS object</li>
<li><strong>Notice the structure</strong>: Each screen has a key (like <code>SPLASH</code>) and a descriptive value</li>
<li><strong>Understand the purpose</strong>: Instead of using strings like <code>&quot;splash&quot;</code> everywhere, we use <code>SCREENS.SPLASH</code></li>
</ol>
<h3 id="why-this-matters-1">ğŸ’¡ Why This Matters</h3>
<p><strong>Constants</strong> prevent typos and make your code more maintainable. Instead of typing <code>&quot;splash&quot;</code> in multiple places (and risking typos like <code>&quot;spalsh&quot;</code>), you use <code>SCREENS.SPLASH</code> once and get autocomplete everywhere. If you need to change the value later, you only change it in one place.</p>
<p><a id="adding-screen-navigation"></a></p>
<h2 id="adding-screen-navigation">ğŸ—ºï¸ Adding Screen Navigation</h2>
<p>Now letâ€™s implement the core navigation system that will control which screen users see. This is where <strong>shared state</strong> really shines!</p>
<ol type="1">
<li><p><strong>Open <code>src/App.jsx</code></strong> and add the necessary imports at the top:</p>
<pre class="jsx"><code>import { useGame } from &#39;./hooks/useGame&#39;;
import { SCREENS } from &quot;./constants/screens&quot;;
import GameMap from &quot;./components/GameMap&quot;;</code></pre></li>
<li><p><strong>Access the shared state</strong> by adding this line inside the App function (before the return):</p>
<pre class="jsx"><code>const { screen } = useGame();</code></pre></li>
<li><p><strong>Add conditional rendering</strong> by replacing the current JSX with:</p>
<pre class="jsx"><code>return (
  &lt;div className=&quot;app-container&quot;&gt;
    {screen === SCREENS.SPLASH &amp;&amp; &lt;SplashScreen /&gt;}
    {screen === SCREENS.PLAYING &amp;&amp; &lt;GameMap /&gt;}
  &lt;/div&gt;
);</code></pre></li>
<li><p><strong>Test the setup</strong>: Run <code>npm run dev</code> to make sure everything still works</p></li>
</ol>
<h3 id="why-this-matters-2">ğŸ’¡ Why This Matters</h3>
<p><strong>Conditional rendering</strong> using <code>&amp;&amp;</code> is a React pattern that shows components only when certain conditions are true. When <code>screen</code> equals <code>SCREENS.SPLASH</code>, the SplashScreen component renders. When it equals <code>SCREENS.PLAYING</code>, GameMap renders instead. This single piece of <strong>shared state</strong> controls what your entire app displays!</p>
<p><a id="using-react-devtools-to-explore-state"></a></p>
<h2 id="using-react-devtools-to-explore-state">ğŸ” Using React DevTools to Explore State</h2>
<p>Letâ€™s use React DevTools to see how <strong>shared state</strong> works behind the scenes and experiment with changing it manually.</p>
<ol type="1">
<li><strong>Open DevTools</strong>: Press F12 or right-click â†’ Inspect</li>
<li><strong>Find Components tab</strong>: Look for â€œComponentsâ€ next to Console, Network, etc.</li>
<li><strong>Locate GameProvider</strong>: Click on GameProvider in the component tree</li>
<li><strong>Examine the hooks</strong>: Look for the screen state value (you may need to click â€œparse hook namesâ€)</li>
<li><strong>Experiment with state</strong>: Change the screen value from â€œsplashâ€ to â€œplayingâ€ and watch the UI update!</li>
<li><strong>Change it back</strong>: Set it back to â€œsplashâ€ to see the SplashScreen return</li>
</ol>
<h3 id="why-this-matters-3">ğŸ’¡ Why This Matters</h3>
<p>React DevTools gives you X-ray vision into your appâ€™s <strong>state</strong>. You can see exactly what data each component has and even modify it in real-time. This is invaluable for debugging and understanding how <strong>shared state</strong> affects your entire app. Notice how changing one value in GameProvider instantly changes what component renders!</p>
<h3 id="bonus-challenge">ğŸ† Bonus Challenge</h3>
<p>Try changing the screen state to different values and see what happens. What occurs when you set it to a value that doesnâ€™t match any of your conditions?</p>
<p><a id="implementing-start-game-functionality"></a></p>
<h2 id="implementing-start-game-functionality">ğŸ® Implementing Start Game Functionality</h2>
<p>Now letâ€™s make your â€œStart Adventureâ€ button actually start the game by updating the <strong>shared state</strong>!</p>
<ol type="1">
<li><p><strong>Open <code>src/components/SplashScreen.jsx</code></strong> and add imports at the top:</p>
<pre class="jsx"><code>import { SCREENS } from &quot;../constants/screens&quot;;
import { useGame } from &quot;../hooks/useGame&quot;;</code></pre></li>
<li><p><strong>Access the state setter</strong> by adding this inside the SplashScreen function (before the return):</p>
<pre class="jsx"><code>const { setScreen } = useGame();</code></pre></li>
<li><p><strong>Create the start game function</strong> (before the return):</p>
<pre class="jsx"><code>const startGame = () =&gt; {
  setScreen(SCREENS.PLAYING);
};</code></pre></li>
<li><p><strong>Update the first GameButton</strong> to use the real function:</p>
<pre class="jsx"><code>&lt;GameButton
  text=&quot;Start Adventure&quot;
  onClick={startGame}
  variant=&quot;primary&quot;
/&gt;</code></pre></li>
<li><p><strong>Test it</strong>: Click the â€œStart Adventureâ€ button and watch the screen change to GameMap!</p></li>
</ol>
<h3 id="why-this-matters-4">ğŸ’¡ Why This Matters</h3>
<p><strong>State setters</strong> like <code>setScreen</code> are functions that update <strong>state</strong> and trigger re-renders. When you call <code>setScreen(SCREENS.PLAYING)</code>, React updates the shared state and re-renders all components that depend on it. This is how one button click can change your entire appâ€™s display!</p>
<p><a id="adding-local-state-for-credits"></a></p>
<h2 id="adding-local-state-for-credits">ğŸ† Adding Local State for Credits</h2>
<p>Letâ€™s implement <strong>local state</strong> for the credits modal to understand the difference between local and shared state.</p>
<ol type="1">
<li><p><strong>Add useState import</strong> at the top of SplashScreen.jsx:</p>
<pre class="jsx"><code>import { useState } from &quot;react&quot;;
import CreditsModal from &quot;./CreditsModal&quot;;</code></pre></li>
<li><p><strong>Add local state</strong> inside the SplashScreen function (before the return):</p>
<pre class="jsx"><code>const [showCredits, setShowCredits] = useState(false);</code></pre></li>
<li><p><strong>Update the Credits button</strong>:</p>
<pre class="jsx"><code>&lt;GameButton
  text=&quot;Credits&quot;
  onClick={() =&gt; setShowCredits(true)}
  variant=&quot;secondary&quot;
/&gt;</code></pre></li>
<li><p><strong>Add the modal</strong> before the closing <code>&lt;/div&gt;</code> tag:</p>
<pre class="jsx"><code>{showCredits &amp;&amp; &lt;CreditsModal onClose={() =&gt; setShowCredits(false)} /&gt;}</code></pre></li>
<li><p><strong>Test both buttons</strong>: Start Adventure should navigate to GameMap, Credits should show the modal</p></li>
</ol>
<h3 id="why-this-matters-5">ğŸ’¡ Why This Matters</h3>
<p><strong>Local state</strong> with <code>useState</code> belongs to a single component, while <strong>shared state</strong> from Context belongs to the entire app. The credits modal only affects SplashScreen, so it uses local state. The screen navigation affects the whole app, so it uses shared state. Choosing the right type of state is a key React skill!</p>
<h3 id="bonus-challenge-1">ğŸ† Bonus Challenge</h3>
<p>Use React DevTools to inspect the SplashScreen component and watch the <code>showCredits</code> state change as you interact with the Credits button.</p>
<p><a id="essential-terms"></a></p>
<h2 id="essential-terms">ğŸ“š Essential Terms</h2>
<p><em>Quick reference for all the state management concepts you just learned:</em></p>
<table>
<colgroup>
<col style="width: 17%"></col>
<col style="width: 35%"></col>
<col style="width: 47%"></col>
</colgroup>
<thead>
<tr class="header">
<th>Term</th>
<th>Definition</th>
<th>Why it matters</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ğŸ§  state</td>
<td>Data that can change over time and causes components to re-render when it changes.</td>
<td>State lets components â€œrememberâ€ information and respond to user interactions dynamically.</td>
</tr>
<tr class="even">
<td>ğŸª hook</td>
<td>Functions starting with â€œuseâ€ that let you use React features like state and context.</td>
<td>Hooks like useState and useContext are your tools for managing data and behavior in components.</td>
</tr>
<tr class="odd">
<td>ğŸŒ Context</td>
<td>Lets a component receive information from distant parents without passing it as props.</td>
<td>Context prevents â€œprop drillingâ€ and provides shared state accessible from any component.</td>
</tr>
<tr class="even">
<td>ğŸ“¦ props</td>
<td>Properties passed from parent to child components, like function parameters but for React.</td>
<td>Props flow data down the component tree, while state manages data within components.</td>
</tr>
<tr class="odd">
<td>ğŸ”„ useState</td>
<td>A React hook that adds local state to functional components.</td>
<td>useState gives individual components their own memory for data that only they need to track.</td>
</tr>
<tr class="even">
<td>ğŸ¯ useContext</td>
<td>A React hook that accesses shared data from a Context Provider.</td>
<td>useContext lets any component access shared state without prop drilling through multiple levels.</td>
</tr>
<tr class="odd">
<td>ğŸ“‹ constants</td>
<td>Static values that donâ€™t change, used to prevent typos and make code more maintainable.</td>
<td>Constants like SCREENS.SPLASH prevent typos and make refactoring easier.</td>
</tr>
<tr class="even">
<td>ğŸ”€ conditional rendering</td>
<td>Showing different components based on state or props using JavaScript expressions.</td>
<td>Conditional rendering with &amp;&amp; lets you control what users see based on app state.</td>
</tr>
<tr class="odd">
<td>ğŸª Provider</td>
<td>A Context component that makes shared state available to all child components.</td>
<td>The Provider pattern wraps your app and gives all components access to shared data.</td>
</tr>
</tbody>
</table>
<p><a id="ask-the-ai"></a></p>
<h2 id="ask-the-ai-state-management-mastery">ğŸ¤– Ask the AI â€” State Management Mastery</h2>
<p>You just implemented both local and shared state, created screen navigation, and experienced the power of Reactâ€™s Context API â€” excellent work!</p>
<p>Now letâ€™s deepen your understanding of state management, hooks, and the React data flow. Here are the most impactful questions to ask your AI assistant about todayâ€™s session:</p>
<ul>
<li><strong>Whatâ€™s the difference between local state and shared state, and when should I use each?</strong></li>
<li><strong>How does the Context API prevent â€œprop drillingâ€ and why is that important?</strong></li>
<li><strong>What happens when I call a state setter function like setScreen?</strong></li>
<li><strong>Why do we use constants like SCREENS.SPLASH instead of just strings?</strong></li>
<li><strong>How does conditional rendering with &amp;&amp; work in React?</strong></li>
<li><strong>What makes hooks special and why do they all start with â€œuseâ€?</strong></li>
<li><strong>How does the GameProvider make state available to all components?</strong></li>
</ul>
<hr />
<h3 id="pro-tip">ğŸ’¬ Pro Tip:</h3>
<p>State management is the heart of React apps. Think of local state as a componentâ€™s private memory and shared state as the appâ€™s global memory. Choose local state when only one component needs the data, and shared state when multiple components need to coordinate.</p>
</body>
</html>
